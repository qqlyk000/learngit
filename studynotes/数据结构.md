数据结构

## 树

### 树的基本概念:

1. 度为m的树中第i层上至多有m^(i-1)个节点(i>=1)
2. 高度为h的m叉树至多有(m^h - 1)/(m-1)个结点
3. 具有n个节点的m叉树的最小高度为[log m (n(m-1)+1)]

### 二叉树：

二叉树是n个结点的有限集合。

- n=0时，二叉树为空；
- n>0时，由根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树也分别是一棵二叉树。

二叉树和度二叉树

- 二叉树可以为空，而度为2的有序树至少有3个结点
- 二叉树的孩子结点始终有左右之分，而度为2有序树的孩子结点次序是相对的

满二叉树：

- 一棵高度为h,且含有2^h -1个结点的二叉树为满二叉树
- 对于编号为i的结点，若存在，其双亲的编号为[i/2],左孩子为2 * i,右孩子为2 * i + 1

##### 完全二叉树:

- 设一个高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号1~n的结点一一对应时，称为完全二叉树。

- 如果不是按照从上到下从左往右依次排序的满二叉树，就不是完全二叉树。

性质：

1. 若1<=[n/2],则结点i为分支结点，否则为叶子结点。
2. 叶子结点只可能在层次最大的两层上出现。对于最大层次的叶子结点，都依次排在最左边的位置上。
3. 度为1的结点若存在，则可能有一个，且是编号最大的分支结点，并孩子结点一定是左结点

##### 二叉排序树

- 左子树上的所有子结点均小于该结点，右子树上的所有子结点均大于该结点

##### 平衡二叉树

- 树上任意结点的左子树和右子树的深度之差不超过1。

#### 二叉树的性质：

1. 非空二叉树上的叶子结点数等于度为2的结点数加1，即n0 = n2 + 1
2. 非空二叉树上第k层上至多有2(k-1)个结点(k>=1)
3. 高度为h的二叉树至多有2^h -1个结点(h>=1)
4. 完全二叉树中
   - 当2 * i <= n时，结点i 的做孩子编号为2 * i ,否则无左孩子。
   - 当2 * i <= n时，结点的右孩子编号为2 * i +1,否则无右孩子。
   - 结点i所在的层次为[log2 ^ i]+1;
5. 具有n个(n>0)结点的完全二叉树的高度为[log2^n]+1或[log2^(n+1)]。

###### 二叉树的存储

1. 二叉树的顺序存储
   - 顺序存储最坏情况下会非常浪费存储空间，比较适合完全二叉树
2. 二叉树的链式存储
   - 含有n个结点的二叉链表中，有n+1个空链域{2 * n - (n-1)}

二叉树的遍历

1. 先序遍历（非空):

   - 根-->左子树-->右子树

   - ```c
     //先序遍历的递归算法
     void PreOrder(BiTree T){
     	if(T!=null){
     		visit(T);
     		PreOrder(T->lchild);
     		PreOrder(T->rchild);
     	}
     }
     ```

   

2. 中序遍历(非空)

   - 左子树-->根-->右子树

   - ```c
     //中序遍历的递归算法
     void PreOrder(BiTree T){
     	if(T!=null){
             PreOrder(T->lchild);
     		visit(T);
     		PreOrder(T->rchild);
     	}
     }
     ```

3. 后序遍历(非空)

   - 左子树-->右子树-->根

   - ```c
     //后序遍历的递归算法
     void PreOrder(BiTree T){
     	if(T!=null){
             PreOrder(T->lchild);
     		PreOrder(T->rchild);
     		visit(T);
     	}
     }
     ```

4. 中序遍历非递归算法

   1. 初始时依次扫描根结点的所有左侧结点并将它们一一进栈

   2. 出栈一个结点，访问它

   3. 扫描该结点的右孩子结点并将其进栈

   4. 依次扫描右孩子结点的所有左侧结点并一一进栈

   5. 反复该过程直至栈空为止

   6. ```c
      void InOrder2(BiTree T){
      	InitStack(S);BiTree p = T;
      	while(p||IsEmpty(s)){
      		if(p){
      			Push(S,p);
      			p=p->lchild;
      		}else{
      			Pop(S,p);
      			visit(p);
      			p=p->rchild;
      		}
      	}
      }
      ```

5. 层次遍历（队列)

   1. 初始将根入队并访问根结点，然后出队

   2. 若有左子树，则将左子树的根入队

   3. 若有右子树，则将右子树的根入队

   4. 然后出队，访问该结点

   5. 反复该过程直到队列空为止

   6. ```c
      void levelOrder(BiTree T){
      	InitQueue(Q);
      	BiTree p;
      	EnQueue(Q,T);
      	while(!isEmpty(Q)){
      		DeQueue(Q,P);
      		visit(p);
      		if(p->lchild!=null);
      			EnQueue(Q,p->lchild);
      		if(p->rchild!=null);
      			EnQueue(Q,p->rchild);	
      	}
      }
      ```

6. 由遍历序列构造二叉树

   1. 先（后）序遍历序列和中序遍历序列可以确定一棵二叉树，而后序遍历序列和先序遍历序列不可以确定一棵二叉树
   2. 中序遍历序列和先序遍历序列
      1. 在先序序列中，第一个节点是根结点
      2. 根结点将中序遍历序列划分为两部分
      3. 然后在先序序列中确定两部分的结点，并且两部分的第一个节点分别为左子树的根和右子树的根
      4. 在子树中递归重复该过程，便能唯一确定一棵二叉树
      5. ![遍历构造二叉树](C:\Users\15744\Desktop\javaweb\遍历构造二叉树.png)



###### 线索二叉树

1. 若无左子树，则将左指针指向其前驱结点

2. 若无右子树，则将右指针指向其后继结点

3. ```c
   typedef struct ThreadNode{
   	ElemType data;
   	struct ThreadNode *lchild,*rchild;
   	int ltag,rtag
   }ThreadNode,*ThreadTree;
   ```

4. 这种结点结构构成的二叉链表作为二叉树的存储结构，称为线索链表

- 孩子兄弟表示法：左孩子，右兄弟



- 树与二叉树的转换规则：每个结点左指针指向它的第一个孩子结点，右指针指向它在树中相邻兄弟结点
- 森林与二叉树的转换规则：将每一棵树转换为二叉树，将每棵二叉树的根依次作为上一课二叉树的右子树
- 树的后根遍历序列与这棵树对应二叉树的中序遍历序列相同 

###### 树的应用

1. 删除
   1. 若被删除结点z是叶结点，则直接删除
   2. 若被删除结点z只有一棵子树，则让z的子树成为z父结点的子树，代替z结点
   3. 若被删除结点z有两棵子树，则让z的中序序列直接后继代替z，并删去直接后继结点。
2. 哈夫曼树的性质:
   1. 每个初始节点都会成为叶节点，双支结点都为新生成的结点
   2. 权值越大离根结点越近，反之权值越小离根结点越远
   3. 哈弗曼树中没有结点的度为1
   4. n个叶子结点的哈夫曼树的结点总数为2n - 1,其中度为2的结点数为n -1
   5. 哈夫曼树并不唯一，所以每个字符对应的哈夫曼编码也不唯一，但带权路径长度相同且最优

## 图

### 图的基本概念

- 图G由顶点集V和边集E相组成，记为G=(V,E),其中V(G)表示图G中顶点的有限非空集，E(G)表示图G中顶点之间的关系(边)集合





 









